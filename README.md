## 실행 방법

1. discovery-service, api, api-gateway 모듈을 차례대로 실행해주세요.

```
./gradlew discovery-service:bootRun
./gradlew api:bootRun
./gradlew api-gateway:bootRun
```
 
2. 실행

api-test.http 파일을 열어서 api 테스트를 진행하실 수 있습니다.

## 구조

### 멀티 모듈

* api : 장소검색과 키워드 조회 api를 제공하는 서비스
* api-gateway : API 게이트웨이
* discovery-service : api와 게이트웨이 인스턴스 정보를 저장하고 제공하는 서비스 디스커버리

### api 서비스 디렉터리 구조 
 
각 도메인별로 디렉터리를 나누는 구조를 사용하였습니다.

* place 디렉터리 : 장소라는 도메인을 중심으로 디렉토리를 구성.
  * api : API 서비스 형태를 정의하는 클래스(Controller)를 모아둔 디렉터리.
  * application : 도메인과 외부 영역을 연결하는 역할을 담당하는 클래스를 모아둔 디렉터리.
    * 단순히 도메인 로직을 실행하고 도메인 객체를 dto로 변환해서 외부로 반환하는 역할을 수행.
  * domain : 도메인과 도메인 서비스 클래스를 모아둔 디렉터리.
  * dto : api body 데이터로 반환될 클래스를 모아둔 디렉터리.
  * exception : 도메인과 관련된 예외처리 클래스를 모아둔 디렉터리.
  * infra : 인프라스트럭처에 관련된 클래스들을 모아둔 디렉터리.
    * 도메인 로직을 구현하는데 필요한 외부 환경을 사용하는 로직을 구현.
    * 카카오와 네이버에서 장소를 검색하는 구현로직이 이곳에 위치.
    
## 요구사항 해결

1. 키워드 증가에 대한 동시성 이슈
   * 키워드 검색 횟수 증가에 대한 update sql을 바로 호출해서 DB의 write lock을 사용했습니다.
   * 비관적 또는 낙관적 락을 사용해서 엔티티를 조회하고 로직으로 풀기엔 기능에 비해 비용 낭비라고 생각했습니다.

2. 다양한 장애 발생
   * exception 처리를 하는 ExceptionHandler 객체(ControllerAdvice)를 만들어서 모든 예외에 대한 처리를 하도록 했습니다.

3. 구글 장소 검색 등 새로운 검색 API 제공자의 추가 시 변경 영역 최소화에 대한 고려
   * 장소 검색에 대한 의존성은 도메인 서비스에 인터페이스로 두고 infra에서 구현 상속하는 구조로써 다형성을 적용하였습니다.
     * 현재는 카카오 구현체, 네이버 구현체, 카카오/네이버 결합 구현체로 총 3개의 구현체가 존재합니다.
   * 외부 장소 검색 api에 대한 request 처리와 response body를 도메인 객체로 변환 처리하는 로직을 갖는 추상 클래스(SearchPlacesProvider)를 두어서 새로운 구현체는 해당 클래스를 상속받아서 최소한의 로직만 작성할 수 있도록 구성했습니다.
     * response body를 도메인 객체로 변환하기 위해 특정 인터페이스를 구현 상속해서 로직을 일원화할 수 있도록 다형성을 활용했습니다.
     * 추상 클래스(SearchPlacesProvider)는 템플릿 메서드 패턴을 적용해서 구현체가 기능을 확장할 수 있도록 적용했습니다.
     
4. 대용량 트래픽에 대한 고려
   * api 게이트웨이를 사용해서 로드밸런싱을 적용했습니다.
      * 다만 DB를 인 메모리로 사용해서 api 서비스 인스턴스마다 DB가 생성되기 때문에 키워드 검색 결과가 달라질 수 있습니다.
   * 장소 검색 결과를 캐싱하도록 처리했습니다.
   
5. 지속적 유지 보수 및 확장 고려
   * SOLID 원칙을 지키는 아키텍처를 구성하는데 노력했습니다.
   * 각 객체는 하나의 책임만 갖도록 구성했습니다.
   * DI는 인터페이스로 의존성을 갖도록 했습니다.
     * 특히 카카오와 네이버의 구현 환경에 종속되지 않고 해당 인프라 구현체가 도메인 서비스에 의존하도록 했습니다.
     * 객체간의 종속성은 인터페이스를 통하도록 해서 기능 변경이나 확장시에 소스코드를 변경하는 것이 아닌 소스코드를 추가하는 것으로 변경과 확장에 염두했습니다.



